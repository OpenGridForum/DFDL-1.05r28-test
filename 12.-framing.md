# 12. Framing

Several properties are common across the various framing styles or are used to distinguish them. Generally, these have to do with position and length for text, bit fields, or opaque data.

## 12.1 Aligned Data

Alignment properties control the leading alignment and trailing alignment regions. That is, the LeadingAlignment and TrailingAlignment regions of the data syntax grammar \(in Section 9.3\). The LeadingAlignment consists of the _**LeadingSkip**_ and _**AlignmentFill**_ regions. The TrailingAlignment contains only the _**TrailingSkip**_ region.

When the alignment properties are applied to an array element, the properties are applied to each occurrence of the element; that is, not only to the first occurrence.

The following properties are used to define alignment rules.

<table>
  <thead>
    <tr>
      <th style="text-align:left"><b>Property Name</b>
      </th>
      <th style="text-align:left"><b>Description</b>
      </th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align:left">alignment</td>
      <td style="text-align:left">
        <p>Non-negative Integer or &apos;implicit&apos;</p>
        <p>A non-negative number that gives the alignment required for the beginning
          of the item. If alignment is needed then the size of the <em><b>AlignmentFill</b></em> grammar
          region will be non-zero if the item must be aligned to a boundary.</p>
        <p>&apos;implicit&apos; specifies that the natural alignment for the representation
          type is used. See the table of implicit alignments Table 15 Implicit Alignment
          in bits for simple elements. The &apos;implicit&apos; alignment of a complex
          element is the alignment of its model group. The &apos;implicit&apos; alignment
          of a model group is always 1. If alignment is &apos;implicit&apos; then
          dfdl:alignmentUnits is ignored.</p>
        <p>For textual data, minimum alignment is mandated by the character-set encoding,
          and this property must be &apos;implicit&apos; or set to a multiple of
          the character-set&apos;s mandatory alignment. See Section 12.1.2.</p>
        <p>Annotation: dfdl:element, dfdl:simpleType, dfdl:sequence, dfdl:choice,
          dfdl:group</p>
      </td>
    </tr>
    <tr>
      <td style="text-align:left">alignmentUnits</td>
      <td style="text-align:left">
        <p>Enum</p>
        <p>Valid values are &apos;bits&apos; or &apos;bytes&apos;</p>
        <p>Scales the alignment so alignment can be specified in either units of
          bits or units of bytes.</p>
        <p>Only used when dfdl:alignment not &apos;implicit&apos;</p>
        <p>Annotation: dfdl:element, dfdl:simpleType, dfdl:sequence, dfdl:choice,
          dfdl:group</p>
      </td>
    </tr>
    <tr>
      <td style="text-align:left">fillByte</td>
      <td style="text-align:left">
        <p>DFDL String Literal</p>
        <p>A single byte specified as a DFDL byte value entity or a single character.
          If a character is specified, it must be a single-byte character in the
          applicable encoding.</p>
        <p>Used on unparsing to fill empty space such as between two aligned elements.</p>
        <p>Used to fill these regions specified in the grammar: <em><b>RightFill</b></em>, <em><b>ElementUnused</b></em>, <em><b>ChoiceUnused,</b></em>  <em><b>LeadingSkip</b></em>, <em><b>AlignmentFill</b></em>,
          and <em><b>TrailingSkip</b></em>.</p>
        <p>Annotation: dfdl:element, dfdl:simpleType, dfdl:sequence, dfdl:choice,
          dfdl:group</p>
      </td>
    </tr>
    <tr>
      <td style="text-align:left">leadingSkip</td>
      <td style="text-align:left">
        <p>Non-negative Integer</p>
        <p>A non-negative number of bytes or bits, depending on dfdl:alignmentUnits,
          to skip before alignment is applied. Gives the size of the grammar region
          having the same name.</p>
        <p>Annotation: dfdl:element, dfdl:simpleType, dfdl:sequence, dfdl:choice,
          dfdl:group</p>
      </td>
    </tr>
    <tr>
      <td style="text-align:left">trailingSkip</td>
      <td style="text-align:left">
        <p>Non-negative Integer</p>
        <p>A non-negative number of bytes or bits, depending on dfdl:alignmentUnits,
          to skip after the element, but before considering the alignment of the
          next element. Gives the size of the grammar region having the same name.</p>
        <p>If dfdl:trailingSkip is specified when dfdl:lengthKind is &apos;delimited&apos;
          then a dfdl:terminator must be specified.</p>
        <p>Annotation: dfdl:element, dfdl:simpleType, dfdl:sequence, dfdl:choice,
          dfdl:group</p>
      </td>
    </tr>
  </tbody>
</table>

Table 14 Aligned Data Properties

There are two properties which control the data alignment by controlling the length of the _**AlignmentFill**_ region

* alignment - an integer 1 or greater
* alignmentUnits - bits or bytes

An element's representation is aligned to N units if P is the first position in the representation and P mod N = 1.  When parsing, the position of the first unit of the data stream is 1. 

For example, if dfdl:alignment is 4, and dfdl:alignmentUnits is 'bytes', then the element's representation must begin at 1 or 1 plus a multiple of 4 bytes. That is, 1, 5, 9, 13, 17 and so on.

The length of the **AlignmentFill** region is measured in bits. If alignmentUnits is 'bytes' then we multiply the alignment value by 8 to get the bit alignment, If the position in the data stream of the start of the **AlignmentFill** region is bit position N, then the length of the **AlignmentFill** region is the smallest non-negative integer L such that \(L + N\) mod B = 1.  The position of the first bit of the aligned component is P = L + N.

The _**LeadingSkip**_ and _**TrailingSkip**_ regions length are controlled by two properties of corresponding names and the dfdl:alignmentUnits property.

### 12.1.1 Implicit Alignment

When dfdl:alignment is 'implicit' the following alignment values are applied for each logical type.

| Type | Alignment |  |  |
| :--- | :--- | :--- | :--- |
| \*\*\*\* | **text** | **binary** |  |
| String | Encoding Specific \(usually 8 bits, with exceptions: See Section 12.1.2\) | Not applicable |  |
| Float |  | 32 |  |
| Double |  | 64 |  |
| Decimal, Integer, nonNegativeInteger |  | Packed decimals: 8 | binary: 8 |
| Long, UnsignedLong |  |  | binary: 64 |
| Int, UnsignedInt |  |  | binary: 32 |
| Short, UnsignedShort |  |  | binary: 16 |
| Byte, UnsignedByte |  |  | binary: 8 |
| DateTime |  |  | binarySeconds: 32, binaryMilliseconds:64 |
| Date |  |  | binarySeconds: 32, binaryMilliseconds:64 |
| Time |  |  | binarySeconds: 32, binaryMilliseconds:64 |
| Boolean |  | 32 |  |
| HexBinary | Not applicable | 8 |  |

Table 15 Implicit Alignment in bits

Note: The above table specifies the implicit alignment in bits, but this does not imply that dfdl:alignmentUnits 'bits' can be specified for all simple types. Rather, dfdl:alignmentUnits and dfdl:lengthUnits are independent and have their own rules for when they are applicable.

### 12.1.2 Mandatory Alignment for Textual Data

_**Textual Data**_ – This term is used to describe data of type xs:string, data with dfdl:representation "text", as well as data being matched to delimiters \(parsing\) or output as delimiters \(unparsing\), and data being matched to regular expressions \(parsing only - as in a dfdl:assert with testKind 'pattern', or an element with dfdl:lengthKind 'pattern'\).

Textual data has mandatory alignment that is character-set-encoding dependent. That is, these mandates come from the character set encoding specified by the dfdl:encoding property.

When processing textual data, it is a Schema Definition Error if the dfdl:alignment and dfdl:alignmentUnits properties are used to specify alignment that is not a multiple of the encoding-specified mandatory alignment.

If the data is not aligned to the proper boundary for the encoding when textual data is processed, then bits are skipped \(parsing\) or filled from dfdl:fillByte \(unparsing\) to achieve the mandatory alignment.

All required character set encodings in DFDL have 8-bit/1-byte alignment.

DFDL standard encodings specify their alignment. See Section 33 Appendix D: DFDL Standard Encodings.

Some implementations MAY include additional implementation-defined encodings which have other alignments.

Note the 16-bit and 32-bit Unicode character set encodings UTF-16, UTF-16BE, UTF-16LE, UTF-32, UTF-32BE, UTF-32LE, all have 8-bit/1-byte alignment.

### 12.1.3 Mandatory Alignment for Packed Decimal Data

Packed decimal data is data with dfdl:binaryNumberRep\[34\] values of 'packed', 'ibm4690Packed' or 'bcd'. This representation stores a decimal digit in a 4 bit nibble. These nibbles must have a multiple of 4-bit alignment. It is a Schema Definition Error otherwise.

\[34\] For dfdl:binaryNumberRep, see Section 13.7 Properties Specific to Number with Binary Representation.

### 12.1.4 Example: AlignmentFill

When dfdl:alignmentUnits is 'bits', and the dfdl:alignment is not a multiple of 8, then the dfdl:bitOrder property affects the alignment by controlling which bits are skipped as part of the grammar _**AlignmentFill**_ region.

In general, the _**AlignmentFill**_ region is _before_ the regions it is aligning, and within a byte, the meaning of _'before'_ is interpreted with respect to the dfdl:bitOrder.

When dfdl:bitOrder is 'mostSignificantBitFirst', then bits with more significance are before bits with less significance, so the _**AlignmentFill**_ region occupies the most significant bits of the byte.

When dfdl:bitOrder is 'leastSignificantBitFirst', then bits with less significance are before bits with more significance, so the _**AlignmentFill**_ region occupies the least significant bits of the byte.

Consider a structure of 2 logical elements. Assume the length and alignment units are bits. \(dfdl:lengthUnits='bits', dfdl:alignmentUnits='bits'\), and that the data is binary with twos-complement binary integers \(dfdl:representation='binary', dfdl:binaryNumberRep='binary'\), and assume the data is at the beginning of the data stream.

`<element name="A" type="xs:int" dfdl:length="2" dfdl:alignment='8'/>  
<!-- having value 1 -->  
<element name="B" type="xs:int" dfdl:length="4" dfdl:alignment='4'/>  
<!-- having value 5 -->`

The above are colorized to highlight the corresponding bits in the data below. The total length due to the alignment region appearing before element 'B' will be 8 bits.

In a format where dfdl:bitOrder is 'mostSignificantBitFirst' the data can be visualized as:

               `01000101  
               AAxxBBBB  
Significance   M      L  
Bit Position   12345678`

In the above, the _**AlignmentFill**_ region is marked with 'x' characters and contains all 0 bit values.

In a format where dfdl:bitOrder is 'leastSignificantBitFirst' the presentation is different:

               `01010001  
               BBBBxxAA  
Significance   M      L  
Bit Position   87654321`

In the above the _**AlignmentFill**_ region still appears before element 'B', and in this case that is in less significant bits of the byte than the bits of content of element 'B', and these bits are displayed to the right of the bits of element 'B'.

## 12.2 Properties for Specifying Delimiters

The following properties apply to all objects that use text delimiters to delimit, that is, to initiate and/or terminate data. Delimiters can apply to binary data; however, they are most often called 'text' delimiters because the concept is much more commonly used for textual data formats.

When parsing, there can multiple delimiter candidates to be matched against the data stream. The matching is performed in a _longest-match preferred_ manner. That is, each of the delimiter candidates is matched against the data, taking the longest match possible for that candidate. Then across all the delimiter candidates, the one with the longest match is the one that is selected as having been found. Once a matching delimiter is found, no other matches will be subsequently attempted \(i.e., there is no backtracking to try shorter matches.\) Additional details on the matching of DFDL String Literals are given in Appendix C: Processing of DFDL String literals.

<table>
  <thead>
    <tr>
      <th style="text-align:left">Property Name</th>
      <th style="text-align:left">Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align:left">initiator</td>
      <td style="text-align:left">
        <p>List of DFDL String Literals or DFDL Expression</p>
        <p>Specifies an ordered whitespace separated list of alternative DFDL String
          Literals one of which marks the beginning of the element or group of elements.</p>
        <p>On unparsing the first initiator in the list is automatically inserted
          into the <em><b>Initiator</b></em> region.</p>
        <p>This property can be computed by way of an expression which returns a
          string containing a whitespace separated list of DFDL String Literals.
          The expression must not contain forward references to elements which have
          not yet been processed. It is not permitted for an expression to return
          an empty string or a string containing only whitespace. That is a Schema
          Definition Error.</p>
        <p>Each string literal in the list, whether apparent in the schema, or returned
          as the value of an expression, is restricted to allow only certain kinds
          of DFDL String Literal syntax:</p>
        <ul>
          <li>DFDL character entities are allowed.</li>
          <li>DFDL Byte Value entities ( %#rXX; ) are allowed.</li>
          <li>DFDL Character Classes NL, WSP, WSP+, WSP*, and ES are allowed.</li>
          <li>If the ES entity or the WSP* entity appear alone as one of the string
            literals in the list, then dfdl:initiatedContent must be &quot;no&quot;.
            This restriction ensures that when dfdl:initiatedContent is &apos;yes&apos;
            that the initiator cannot match zero-length data.</li>
        </ul>
        <p>If the above rules are not followed it is a Schema Definition Error.</p>
        <p>The <em><b>Initiator</b></em> region contains one of the initiator strings
          defined by dfdl:initiator.</p>
        <p>When parsing, the list of initiator values is processed in a greedy manner,
          with the longest match preferred. That is, the initiator with the longest
          match is the one that is selected as having been found. Once a matching
          initiator is found, no other matches will be subsequently attempted (i.e.,
          there is no backtracking).</p>
        <p>When an initiator is specified, it is a processing error if the component
          is required and one of the values is not found.</p>
        <p>If dfdl:initiator is &quot;&quot; (the empty string), that is the way
          a DFDL schema expresses a format which does not use initiators. Hence,
          the <em><b>Initiator</b></em> region is of length zero.</p>
        <p>If dfdl:ignoreCase is &apos;yes&apos; then the case of the string is ignored
          by the parser.</p>
        <p>Annotation: dfdl:element, dfdl:simpleType, dfdl:sequence, dfdl:choice,
          dfdl:group</p>
      </td>
    </tr>
    <tr>
      <td style="text-align:left">terminator</td>
      <td style="text-align:left">
        <p>List of DFDL String Literals or DFDL Expression</p>
        <p>Specifies an ordered whitespace separated list of alternative text strings
          that one of which marks the end of an element or group of elements. The
          strings MUST be searched for in the longest first order.</p>
        <p>This property can be computed by way of an expression which returns a
          string of whitespace separated list of values. The expression must not
          contain forward references to elements which have not yet been processed.</p>
        <p>This property can be used to determine the length of an element as described
          in Section <a href>12.3.2</a> dfdl:lengthKind &apos;delimited&apos;.</p>
        <p>Each string literal in the list, whether apparent in the schema, or returned
          as the value of an expression, is restricted to allow only certain kinds
          of DFDL String Literal syntax:</p>
        <ul>
          <li>DFDL character entities are allowed.</li>
          <li>DFDL Byte Value entities ( %#rXX; ) are allowed.</li>
          <li>DFDL Character Classes NL, WSP, WSP+, WSP*, and ES are allowed.</li>
          <li>Neither the ES entity nor the WSP* entity may appear on their own as one
            of the string literals in the list when the parser is determining the length
            of a component by scanning for delimiters.</li>
        </ul>
        <p>If the above rules are not followed it is a Schema Definition Error.</p>
        <p>The <em><b>Terminator</b></em> grammar region contains one of the terminator
          strings defined by dfdl:terminator.</p>
        <p>If dfdl:terminator is &quot;&quot; (the empty string), that is the way
          a DFDL schema expresses a format which does not use terminators. Hence,
          the <em><b>Terminator</b></em> region is of length zero. It is not permitted
          for an expression to return an empty string, that is a Schema Definition
          Error.</p>
        <p>When parsing, the list of values is processed in a greedy manner, with
          the longest match preferred. That is, the terminator with the longest match
          is the one that is selected as having been &apos;found&apos;. Once a matching
          terminator is found, no other matches will be subsequently attempted (i.e.,
          there is no backtracking).</p>
        <p>When a terminator is expected it is a processing error if no matching
          terminator is found. However, if dfdl:documentFinalTerminatorCanBeMissing
          is specified then it is not an error if the last terminator in the data
          stream is not found.</p>
        <p>On unparsing the first terminator in the list is automatically inserted
          in the Terminator region.</p>
        <p>If dfdl:ignoreCase is &apos;yes&apos; then the case of the string is ignored
          by the parser.</p>
        <p>Annotation: dfdl:element, dfdl:simpleType, dfdl:sequence, dfdl:choice,
          dfdl:group</p>
      </td>
    </tr>
    <tr>
      <td style="text-align:left">emptyValueDelimiterPolicy</td>
      <td style="text-align:left">
        <p>Enum</p>
        <p>Valid values are &apos;none&apos;, &apos;initiator&apos;, &apos;terminator&apos;
          or &apos;both&apos;</p>
        <p>Indicates that when an element in the data stream is empty, which of initiator,
          terminator, both, or neither must be present.</p>
        <p>Ignored if both dfdl:initiator and dfdl:terminator are &quot;&quot; (empty
          string).</p>
        <p>&apos;initiator&apos; indicates that, on parsing, if the content region
          (which can be either the SimpleContent region or the ComplexContent region
          defined in Section 9.3) is empty then the dfdl:initiator must be present.
          It also indicates that on unparsing when the content region is empty that
          the dfdl:initiator will be output.</p>
        <p>&apos;terminator&apos; indicates that, on parsing, if the content region
          is empty then the dfdl:terminator must be present. It also indicates that
          on unparsing when the content region is empty the dfdl:terminator will
          be output.</p>
        <p>&apos;both&apos; indicates that, on parsing, if the content region is
          empty both the dfdl:initiator and dfdl:terminator must be present. On unparsing
          when the content region is empty the dfdl:initiator followed by the dfdl:terminator
          will be output.</p>
        <p>&apos;none&apos; indicates that if the content region is empty neither
          the dfdl:initiator or dfdl:terminator must be present. On unparsing when
          the content region is empty nothing will be output.</p>
        <p>It is a Schema Definition Error if dfdl:emptyValueDelimiterPolicy set
          to &apos;none&apos; or &apos;terminator&apos; when the parent group has
          dfdl:initiatedContent &apos;yes&apos;.</p>
        <p>This property plays an important role in establishing empty representation.
          See 9.3.2 Empty Representation for details.</p>
        <p>This property is ignored if the element is fixed-length and length is
          not zero (as no empty representation is possible).</p>
        <p>The value of dfdl:emptyValueDelimiterPolicy SHOULD only be checked if
          there is a dfdl:initiator or dfdl:terminator in scope. If so, and dfdl:emptyValueDelimiterPolicy
          is not set, it is a Schema Definition Error.</p>
        <p>If dfdl:initiator is not &quot;&quot; and dfdl:terminator is &quot;&quot;
          and dfdl:emptyValueDelimiterPolicy is &apos;terminator&apos; it is a Schema
          Definition Error.</p>
        <p>If dfdl:terminator is not &quot;&quot; and dfdl:initiator is &quot;&#x201D;
          and dfdl:emptyValueDelimiterPolicy is &apos;initiator&apos; it is a Schema
          Definition Error.</p>
        <p>It is not a Schema Definition Error if dfdl:emptyValueDelimiterPolicy
          is &apos;both&apos; and one or both of dfdl:initiator and dfdl:terminator
          is &quot;&quot;. This is to accommodate the common use of setting &apos;both&apos;
          as a schema-wide setting.</p>
        <p>It is a Schema Definition Error if dfdl:emptyValueDelimiterPolicy is in
          effect and is set to &apos;none&apos; or &apos;terminator&apos; when the
          parent xs:sequence has dfdl:initiatedContent &apos;yes&apos;.</p>
        <p>Annotation: dfdl:element, dfdl:simpleType</p>
      </td>
    </tr>
    <tr>
      <td style="text-align:left">documentFinalTerminatorCanBeMissing</td>
      <td style="text-align:left">
        <p>Enum</p>
        <p>Valid values are &apos;yes&apos;, &apos;no&apos;</p>
        <p>When the dfdl:documentFinalTerminatorCanBeMissing property is true, then
          when an element is the last element in the data stream, then on parsing,
          it is not an error if the terminator is not found, and the terminator is
          considered to be logically present for the purposes of establishing representation,
          per Section 9.4.2.</p>
        <p>For example, if the data are in a file, and the format specifies lines
          terminated by the newline character (typically LF or CRLF), then if the
          last line is missing its newline, then this would normally be an error,
          but if dfdl:documentFinalTerminatorCanBeMissing is true, then this is not
          a processing error.</p>
        <p>On unparsing the terminator is always written out regardless of the state
          of this property.</p>
        <p>Annotation: dfdl:format (but applies to elements only)</p>
      </td>
    </tr>
    <tr>
      <td style="text-align:left">outputNewLine</td>
      <td style="text-align:left">
        <p>DFDL String Literal or DFDL Expression</p>
        <p>Specifies the character or characters that will be used to replace the
          %NL; character class entity during unparse.</p>
        <p>(The %NL; entity is defined in Section 6.3.1.3 DFDL Character Class Entities
          in DFDL String Literals.)</p>
        <p>It is a Schema Definition Error if any of the characters are not in the
          set of characters allowed by the DFDL entity %NL; Only individual characters
          or the %CR;%LF; combination are allowed.</p>
        <p>It is a Schema Definition Error if the DFDL entity %NL; is specified</p>
        <p>This property can be computed by way of an expression which returns a
          DFDL string literal. The expression must not contain forward references
          to elements which have not yet been processed.</p>
        <p>Annotation: dfdl:element, dfdl:simpleType, dfdl:sequence, dfdl:choice,
          dfdl:group</p>
      </td>
    </tr>
    <tr>
      <td style="text-align:left">emptyElementParsePolicy</td>
      <td style="text-align:left">
        <p>Enum</p>
        <p>Valid values are &quot;treatAsAbsent&quot; or &quot;treatAsEmpty&quot;.</p>
        <p>This property describes the behavior of the DFDL processor for occurrences
          of elements of any type that have the empty representation.</p>
        <p>When &apos;treatAsEmpty&apos; if an occurrence of an element has the empty
          representation when parsed, the behaviour is as stated in section 9 for
          an occurrence with empty representation. Consequently, default values or
          empty strings may be added to the Infoset.</p>
        <p>When &apos;treatAsAbsent&apos; if an occurrence of an element has the
          empty representation when parsed, the behaviour is as stated in section
          9 for an absent occurrence. Consequently, default values or empty strings
          are never added to the Infoset.</p>
        <p>Annotation: dfdl:element, dfdl:simpleType</p>
      </td>
    </tr>
  </tbody>
</table>

Table 16 Properties for Specifying Delimiters

## 12.3 Properties for Specifying Lengths

These properties are used to determine the content length of an element and apply to elements of all types \(simple and complex\).

<table>
  <thead>
    <tr>
      <th style="text-align:left">Property Name</th>
      <th style="text-align:left">Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align:left">lengthKind</td>
      <td style="text-align:left">
        <p>Enum</p>
        <p>Controls how the content length of the component is determined.</p>
        <p>Valid values are: &apos;explicit&apos;, &apos;delimited&apos;, &apos;prefixed&apos;,
          &apos;implicit&apos;, &apos;pattern&apos;, &apos;endOfParent&apos;</p>
        <p>A full description of each enumeration is given in the subsections of
          this section beginning with Section 12.3.1.</p>
        <p>&apos;explicit&apos; means the length of the element is given by the dfdl:length
          property.</p>
        <p>&apos;delimited&apos; means the element length is determined by scanning
          for a terminator or separator.</p>
        <p>&apos;prefixed&apos; means the length of the element is given by an immediately
          preceding PrefixLength data region the format of which is specified using
          dfdl:prefixLengthType.</p>
        <p>&apos;implicit means the length is to be determined in terms of the type
          of the element and its schema-specified properties if any.</p>
        <p>&apos;pattern&apos; means the length of the element is given by scanning
          for a regular expression specified using the dfdl:lengthPattern property.</p>
        <p>&apos;endOfParent&apos; means that the length extends to the end of the
          containing (parent) construct.</p>
        <p>Annotation: dfdl:element, dfdl:simpleType</p>
      </td>
    </tr>
    <tr>
      <td style="text-align:left">lengthUnits</td>
      <td style="text-align:left">
        <p>Enum</p>
        <p>Valid values &apos;bytes&apos;, &apos;characters&apos;, &apos;bits&apos;.</p>
        <p>Specifies the units to be used whenever a length is being used to extract
          or write data. Applicable when dfdl:lengthKind is &apos;explicit&apos;,
          &apos;implicit&apos; (for xs:string and xs:hexBinary) or &apos;prefixed&apos;.</p>
        <p>Usage is restricted as follows:</p>
        <ul>
          <li>&apos;characters&apos; may only be used for complex elements and simple
            elements with text representation.</li>
          <li>&apos;bits&apos; may only be used for xs:boolean, xs:byte, xs:short, xs:int,
            xs:long, xs:unsignedByte, xs:unsignedShort, xs:unsignedInt, and xs:unsignedLong
            simple types with binary representation, and for calendar (date and time)
            simple types with binary packed representation.</li>
          <li>&apos;bytes&apos; must be used for type xs:hexBinary and may be used for
            any other type.</li>
          <li>&apos;bytes&apos; must be used for types xs:float and xs:double with binary
            representation.</li>
        </ul>
        <p>Annotation: dfdl:element, dfdl:simpleType</p>
      </td>
    </tr>
  </tbody>
</table>

Table 17 Properties for Specifying Length

### 12.3.1 dfdl:lengthKind 'explicit'

When dfdl:lengthKind is 'explicit' the length of the item is given by the dfdl:length property.

When the value of the dfdl:length property is a constant, it is used both when parsing and unparsing.

When unparsing an element with dfdl:lengthKind 'explicit' and where dfdl:length is an expression, then the data in the Infoset is treated as fixed-length and the dfdl:length property, whether literal constant or expression, is evaluated to provide the length to use.

When parsing and dfdl:lengthKind is 'explicit', delimiter scanning is turned off and in-scope delimiters are not looked for within or between elements.

<table>
  <thead>
    <tr>
      <th style="text-align:left">Property Name</th>
      <th style="text-align:left">Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align:left">length</td>
      <td style="text-align:left">
        <p>Non-negative Integer or DFDL Expression.</p>
        <p>Only used when lengthKind is &apos;explicit&apos;.</p>
        <p>Specifies the length of this element in units that are specified by the
          dfdl:lengthUnits property.</p>
        <p>This property can be computed by way of an expression which returns a
          non-negative integer. The expression must not contain forward references
          to elements which have not yet been processed.</p>
        <p>Annotation: dfdl:element, dfdl:simpleType</p>
      </td>
    </tr>
  </tbody>
</table>

Table 18 The dfdl:length Property

When dfdl:lengthKind 'explicit', the method of extracting data is described in section: 12.3.7 Elements of Specified Length

### 12.3.2 dfdl:lengthKind 'delimited'

On parsing, the length of an element with dfdl:lengthKind 'delimited' is determined by scanning the data stream for the delimiter.

The data stream is scanned for any of

* the element's terminator \(if specified\)
* an enclosing construct's separator or terminator
* the end of an enclosing element designated by its known length
* the end of the data stream

dfdl:lengthKind 'delimited' may be specified for

* elements of simple type with text representation
* elements of number or calendar \(date and time\) simple type with dfdl:representation 'binary' that have a packed decimal representation
* elements of type xs:hexBinary
* elements of complex type.

The rules for resolving ambiguity between delimiters are:

1. When two delimiters have a common prefix, the longest delimiter is tried first.
2. When two delimiters have the same length, but on different schema components, the innermost \(most deeply nested\) delimiter is tried first.
3. When the separator and terminator on a group have the same value, then at a point in the data where either the separator or terminator could be found, the separator is tried first. \(Speculative execution may try the terminator subsequently\).
4. If the length of the delimiters cannot be determined because character class entities of variable length are being used then the delimiters MUST each be matched against the data, and the longest matching delimiter is taken as the match for the delimiter.
5. Ties \(same matched length\) are broken by giving a separator priority over a terminator of a sequence, or by choosing the innermost, or first in schema order.

When unparsing a simple element with text representation, the length in the data stream is the length of the content region, but padded to a minimum length, if one is specified.

A minimum length is specified via the dfdl:textPadKind='padChar' property binding along with:

* for xs:string elements: the XSD minLength facet.
* for other simple types dfdl:textOutputMinLength.

When unparsing a simple element with binary representation, then for hexBinary the length is the number of bytes in the Infoset value padded to the XSD minLength facet value using dfdl:fillByte, and for the other types the length is the minimum number of bytes to represent the value and any sign.

When unparsing a complex element, the length is that of the ComplexContent region.

#### 12.3.2.1 Non-Delimited Elements within Delimited Constructs

When a simple or complex element has a specified length, dfdl:lengthKind 'pattern', or dfdl:lengthKind 'endOfParent' then delimiter scanning is suspended for the duration of the processing of that element.

This allows formats to be parsed which are delimited but have nested elements which contain non-character data so long as that nested data can be isolated from the delimited data context surrounding it.

#### 12.3.2.2 Delimited Binary Data

Formats involving binary data, most notably packed decimals, can use delimiter scanning but care must be taken that the delimiters cannot match data represented in these formats. In particular, the delimiters must be chosen with knowledge that BCD data can contain any byte both of whose nibbles are 0 to 9 \(that is, excluding A to F\). Packed data adds bytes with a sign indicator, that is, a nibble in the range A to F.

General binary data can contain any bit pattern whatsoever, so delimiter scanning for numbers and calendar types with dfdl:representation 'binary' is disallowed, with the specific exception of packed decimals. Delimiter scanning is also allowed for type xs:hexBinary.

Implementation Note: Scanning for delimiters when data is binary, or when using byte-value \(aka raw byte\) entities in delimiters, means that a simple character-based delimiter scanner IS NOT sufficient, as the delimiter may not be representable as characters.

### 12.3.3 dfdl:lengthKind 'implicit'

When dfdl:lengthKind is 'implicit', the length is determined in terms of the type of the element and its schema-specified properties.

For complex elements, 'implicit' means the length is determined by the combined lengths of the contained children, that is the ComplexValue region, and the ElementUnused region is of size 0. However, note that alignment regions inside the contained children within the ComplexValue region may be of different lengths depending on the ComplexValue's starting position alignment.

For simple elements the length is fixed and is given in Table 19 Length in Bits for SimpleTypes when dfdl:lengthKind is 'implicit' .

| Type | Length |  |  |
| :--- | :--- | :--- | :--- |
| \*\*\*\* | **text** | **binary** |  |
| String | The XSD maxLength facet gives length in characters, but this is also the length in bytes. \(See note below: character set encoding must be single-byte.\) Multiply by 8 to get number of bits. | Not applicable |  |
| Float | Not allowed | 32 bits |  |
| Double | Not allowed | 64 bits |  |
| Decimal, Integer, nonNegativeInteger | Not allowed | packed decimal: Not allowed | binary: Not allowed |
| Long, UnsignedLong | Not allowed |  | binary: 64 bits |
| Int, UnsignedInt | Not allowed |  | binary: 32 bits |
| Short, UnsignedShort | Not allowed |  | binary: 16 bits |
| Byte, UnsignedByte | Not allowed |  | binary: 8 bits |
| DateTime | Not allowed |  | binarySeconds: 32 bits, binaryMilliseconds: 64 bits. |
| Date | Not allowed |  | binarySeconds: Not allowed, binaryMilliseconds: Not allowed |
| Time | Not allowed |  | binarySeconds: Not allowed, binaryMilliseconds: Not allowed |
| Boolean | Length of longest of dfdl:textBooleanTrueRep and dfdl:textBooleanFalseRep values | 32 bits |  |
| HexBinary | Not applicable | The XSD maxLength facet gives the length in bytes. Multiply by 8 to convert to number of bits. |  |

Table 19 Length in Bits for SimpleTypes when dfdl:lengthKind is 'implicit'

* 'Not Allowed' means that there is no implicit length for the combination of simple type and representation, and it is a Schema Definition Error if dfdl:lengthKind 'implicit' is specified.
* packed decimal means dfdl:binaryNumberRep is 'packed', 'bcd', or 'ibm4690Packed'
* binary means dfdl:binaryNumberRep is 'binary'
* binarySeconds means dfdl:binaryCalendarRep is 'binarySeconds'
* binaryMilliseconds means dfdl:binaryCalendarRep is 'binaryMilliseconds'.

When dfdl:lengthKind is 'implicit', the method of extracting data is described in section: 12.3.7 Elements of Specified Length.

It is a Schema Definition Error if type is xs:string and dfdl:lengthKind is 'implicit' and dfdl:lengthUnits is 'bytes' and encoding is not an SBCS \(exactly 1 byte per character code\) encoding. This prevents a scenario where validation against the XSD maxLength facet is in characters but parsing and unparsing using the XSD maxLength facet is in bytes.

### 12.3.4 dfdl:lengthKind 'prefixed'

When dfdl:lengthKind is 'prefixed' the length of the element is given by the integer value of the PrefixLength region specified using dfdl:prefixLengthType. The property dfdl:prefixIncludesPrefixLength also can be used to adjust the length appropriately.

When dfdl:lengthKind is 'prefixed' the method of extracting data is described in section: 12.3.7 Elements of Specified Length

When dfdl:lengthKind is 'prefixed', delimiter scanning is turned off and in-scope delimiters are not looked for within or between elements.

<table>
  <thead>
    <tr>
      <th style="text-align:left">Property Name</th>
      <th style="text-align:left">Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align:left">prefixIncludesPrefixLength</td>
      <td style="text-align:left">
        <p>Enum</p>
        <p>Valid values are &apos;yes&apos;, &apos;no&apos;</p>
        <p>Specifies whether the length given by a prefix includes the length of
          the prefix as well as the length of the content region which can be either
          the SimpleContent region or the ComplexContent region defined in Section
          9.3 DFDL Data Syntax Grammar.</p>
        <p>Used only when dfdl:lengthKind &apos;prefixed&apos;.</p>
        <p>Annotation: dfdl:element, dfdl:simpleType</p>
      </td>
    </tr>
    <tr>
      <td style="text-align:left">prefixLengthType</td>
      <td style="text-align:left">
        <p>QName</p>
        <p>Name of a simple type derived from xs:integer or any subtype of it.</p>
        <p>This type, with its DFDL annotations specifies the representation of the
          length prefix, which is in the PrefixLength region.</p>
        <p>It is a Schema Definition Error if the xs:simpleType specifies any of:</p>
        <ul>
          <li>dfdl:lengthKind &apos;delimited&apos;, &apos;endOfParent&apos;, or &apos;pattern&apos;</li>
          <li>dfdl:lengthKind &apos;explicit&apos; where length is an expression</li>
          <li>dfdl:outputValueCalc</li>
          <li>dfdl:initiator or dfdl:terminator other than empty string</li>
          <li>dfdl:alignment other than &apos;1&apos;</li>
          <li>dfdl:leadingSkip or dfdl:trailingSkip other than &apos;0&apos;.</li>
        </ul>
        <p>Annotation: dfdl:element, dfdl:simpleType</p>
      </td>
    </tr>
  </tbody>
</table>

Table 20 Properties for dfdl:lengthKind 'prefixed'

The representation of the element is in two parts.

1. The 'prefix length' is an integer which specifies the length of the element's content. The representation of the length prefix is described by a simple type which is identified using the dfdl:prefixLengthType property.
2. The content of the element.

When parsing, the length of the element's content is obtained by parsing the simple type specified by dfdl:prefixLengthType to obtain an integer value. Note that all required properties must be present on the specified simple type or defaulted because there is no element declaration to supply any missing required properties.

If the dfdl:prefixIncludesPrefixLength property is 'yes' then the length of the element's content is the value of the prefix length minus the length of the content of the prefix length.

If the prefix type is dfdl:lengthKind 'implicit' or 'explicit' then the dfdl:lengthUnits properties of both the prefix type and the element must be the same.

The DFDL properties that specify the format of the prefix come from annotations directly on the dfdl:prefixLengthType's type definition, and from the default format annotation for the schema document containing the definition of that type. If the using-element resides in a separate schema, the simple type does not pick up values from the element's schema's default dfdl:format annotation.

When unparsing, the length of the element's content region can be determined first as described below. Then the value of the prefix length MUST be adjusted based on the value of the dfdl:prefixIncludesPrefixLength property.

Then the prefix length can be written to the data stream using the properties on the dfdl:prefixLengthType, and finally the element's content can be written to the data stream.

Consider this example:

`<xs:element name="myString" type="xs:string"  
 dfdl:lengthKind="prefixed"  
 dfdl:prefixIncludesPrefixLength="no"  
 dfdl:prefixLengthType="packed3"/>  
<xs:simpleType name="packed3"  
 dfdl:representation="binary"  
 dfdl:binaryNumberRep="packed"  
 dfdl:lengthKind="explicit"  
 dfdl:length="2" >  
 <xs:restriction base="integer" />  
</xs:simpleType>`

In the above, the string has a prefix length of type 'packed3' containing 3 packed decimal digits.

The property dfdl:prefixIncludesPrefixLength is an enumeration which allows the length computation to be varied to include or exclude the length of the prefix element itself.

The prefix length's value contains the length measured in units given by dfdl:lengthUnits.

When parsing, if the dfdl:lengthUnits are bits, then any number of bits can be in the representation. However, the same is not true when unparsing. The DFDL Infoset does not store the number of bits in a number, so the number of bits will always be a multiple of 8 bits.

When unparsing, the value of the prefix is computed automatically by obtaining the length of the element's content.

For a simple element with text representation, the length is computed as for dfdl:lengthKind 'delimited'.

For a simple element with binary representation, the length is given in the table below.

For a complex element, the length is that of the ComplexContent region.

| Type | Length |  |
| :--- | :--- | :--- |
| String | Not applicable |  |
| Float | 32 |  |
| Double | 64 |  |
| Decimal, Integer, NonNegativeInteger | Compute the minimum number of bytes to represent the value \(per dfdl:binaryNumberRep\) and sign \(if applicable\). Multiply by 8 for number of bits. |  |
| Long, UnsignedLong | packed decimal: as Decimal | binary: 64 |
| Int, UnsignedInt |  | binary: 32 |
| Short, UnsignedShort |  | binary: 16 |
| Byte, UnsignedByte |  | binary: 8 |
| DateTime |  | binarySeconds: 32, binaryMilliseconds:64 |
| Date |  | binarySeconds: Not allowed, binaryMilliseconds: Not allowed |
| Time |  | binarySeconds: Not allowed, binaryMilliseconds: Not allowed |
| Boolean | 32 |  |
| HexBinary | Compute the number of bytes in the Infoset value padded to the value of the XSD minLength facet \(which gives minimum length in bytes\) using dfdl:fillByte if necessary. This gives the unparse length in bytes. Multiply by 8 for the number of bits. |  |

Table 21 Unparse Lengths \(in Bits\) for Binary Data with dfdl:lengthKind 'prefixed'

#### 12.3.4.1 Nested Prefix Lengths\[35\]

It is possible for a prefix length, as specified by dfdl:prefixLengthType, to itself have a prefix length

It is a Schema Definition Error if this nesting exceeds 1 deep. That is, an element can have a prefix length, which defines a PrefixLength region \(see Section 9.3 DFDL Data Syntax Grammar\). The PrefixLength region can itself have a type which also specifies a prefix length, thereby defining a PrefixPrefixLength region. It is a Schema Definition Error unless the type associated with the PrefixPrefixLength is different from the type associated with the PrefixLength.

\[35\] This feature allows DFDL to describe the needed “one more level” of prefix that is needed for modeling an ASN.1 format, but without the complexities of general recursion.

### 12.3.5 dfdl:lengthKind 'pattern'

The dfdl:lengthKind 'pattern' means the length of the element is given by a regular expression specified using the dfdl:lengthPattern property. The DFDL processor scans the data stream to determine a string value that is the match to a regular expression. The pattern is only used on parsing.

When dfdl:lengthKind is 'pattern', delimiter scanning is turned off and in-scope delimiters are not looked for within or between elements.

<table>
  <thead>
    <tr>
      <th style="text-align:left">Property Name</th>
      <th style="text-align:left">Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align:left">lengthPattern</td>
      <td style="text-align:left">
        <p>DFDL Regular Expression.</p>
        <p>Only used when lengthKind is &apos;pattern&apos;.</p>
        <p>Specifies a regular expression that, on parsing, is executed against the
          data stream to determine the length of the element.</p>
        <p>The data stream beginning at the starting offset of the content region
          (which can be either the SimpleContent region or the ComplexContent region
          defined in Section 9.3 DFDL Data Syntax Grammar) of the element is interpreted
          as a stream of characters in the encoding of the element, and the regular
          expression contained in the dfdl:lengthPattern property is executed against
          that stream of characters. When the element is complex the encoding used
          is the dfdl:encoding of the complex element itself.</p>
        <p>It is a Schema Definition Error if there is no value for the dfdl:encoding
          property in scope.</p>
        <p>DFDL Escape Schemes (per dfdl:escapeSchemeRef) are not used when executing
          the regular expression.</p>
        <p>If the pattern matching of the regular expression reads data that cannot
          be decoded into characters of the current encoding, then the behavior is
          controlled by the dfdl:encodingErrorPolicy property. See dfdl:encodingErrorPolicy
          in Section 11 Properties Common to both Content and Framing.</p>
        <p>Annotation: dfdl:element, dfdl:simpleType</p>
      </td>
    </tr>
  </tbody>
</table>

Table 22 The dfdl:lengthPattern Property

On unparsing the behavior is the same as for dfdl:lengthKind 'prefixed'.

When the DFDL regular expression is matched against data:

* The data is considered to be text in the character set encoding specified by the dfdl:encoding property, regardless of the actual representation of the element.
* The data is decoded from the specified encoding into Unicode before the actual matching takes place.
* If there is no match \(i.e., the length of the data found to match the pattern is zero\) it is not a processing error but instead it means the length is zero.

### 12.3.6 dfdl:lengthKind 'endOfParent'

The dfdl:lengthKind 'endOfParent' means that the element is terminated either by the end of the data stream, or the end of an enclosing complex element with dfdl:lengthKind ‘explicit’, ‘pattern’, ‘prefixed’ or ‘endOfParent’, or the end of an enclosing choice with dfdl:choiceLengthKind ‘explicit’. The ‘parent’ element or choice does not have to be the immediate enclosing component of the element, but there must be no other components defined between the element specifying dfdl:lengthKind 'endOfParent' and the end of the parent.

A convenient way of describing the parent is as a 'box', being defined as a portion of the data stream that has an established content length prior to the parsing of its children. If the parent is such a ‘box’ then the element specifying dfdl:lengthKind ‘endOfParent’ is the last element in the ‘box’ and its content extends to the end of the ‘box’.

A dfdl:lengthKind of 'endOfParent' can only be used on simple and complex elements in the following locations:

* When the immediate containing model group is a sequence, on the final element in the sequence
* When the immediate containing model group is a choice, on any element that is a branch of the choice
* A simple type or global element declaration referenced by one of the above.
* A global element declaration that is the document root.

It is a Schema Definition Error if:

* the element has a terminator.
* the element has dfdl:trailingSkip not equal to 0.
* the element has maxOccurs &gt; 1.
* any other model-group is defined between this element and the end of the enclosing component.
* any other represented element is defined between this element and the end of the enclosing component.
* the parent is an element with dfdl:lengthKind 'implicit' or 'delimited'.
* the element has text representation, does not have a single-byte character set encoding, and the effective length units of the parent is not ‘characters’.
* The effective length units of the parent are:
  * dfdl:lengthUnits if parent is an element with dfdl:lengthKind ‘explicit’ or ‘prefixed’;
  * ‘characters’ if parent is an element with dfdl:lengthKind ‘pattern’;
  * ‘bytes’ if parent is a choice with dfdl:choiceLengthKind ‘explicit’;
  * ‘characters’ if the element is the document root;
  * the effective length units of the parent’s parent if parent is an element with dfdl:lengthKind ‘endOfParent’

If the element is in a sequence then it is a Schema Definition Error if:

* the dfdl:separatorPosition of the sequence is 'postfix'
* the dfdl:sequenceKind of the sequence is not 'ordered'
* the sequence has a terminator
* there are floating elements in the sequence
* the sequence has a non-zero dfdl:trailingSkip

If the element is in a choice where dfdl:choiceLengthKind is 'implicit' then it is a Schema Definition Error if:

* the choice has a terminator
* the choice has a non-zero dfdl:trailingSkip

A simple element must have one of:

* type xs:string
* dfdl:representation 'text'
* type xs:hexBinary
* dfdl:representation 'binary' and a packed decimal representation

A complex element can have dfdl:lengthKind 'endOfParent'. If so then its last child element can be any dfdl:lengthKind including 'endOfParent'.

The dfdl:lengthKind 'endOfParent' can also be used on the document root to allow the last element to consume the data up to the end of the data stream.

The use of dfdl:lengthKind ‘endOfParent’ is distinct from the situation where the length of the last element in the parent is known but is not sufficient to fill the parent. In the latter case the remaining data are ignored on parsing and filled with dfdl:fillByte on unparsing.

When parsing an element with dfdl:lengthKind ‘endOfParent’, delimiter scanning is turned off and in-scope terminating delimiters are not looked for within the element.

When unparsing an element with dfdl:lengthKind ‘endOfParent’, if the parent is a complex element with dfdl:lengthKind 'explicit' where dfdl:length is not an expression, or a choice with dfdl:choiceLengthKind 'explicit', then the element with dfdl:lengthKind 'endOfParent' is padded or filled in the usual manner to the required length, by completing the _**LeftPadding**_, _**RightPad**_, _**RightFill**_, _**ElementUnused**_, or _**ChoiceUnused**_ regions of the data syntax grammar \(Section 9.3\) as appropriate.

### 12.3.7 Elements of Specified Length

An element has a specified length when dfdl:lengthKind is 'explicit', 'implicit' \(simple type only\) or 'prefixed'. The units that the length represents are specified by the dfdl:lengthUnits property except where noted in Section 12.3.3.

Using specified length, it is possible for an element to have content length longer than needed to represent just the data value. For example, a simple text element may be padded in the _**RightPadding**_ region if the data is not long enough.

When an element has specified length but appears inside a complex type element having delimited length kind, delimiter scanning is turned off and in-scope delimiters are not looked for within or between elements.

An element of specified length with dfdl:lengthKind 'implicit' or 'explicit' where dfdl:length is not an expression has a known length when unparsing.

An element of specified length with dfdl:lengthKind 'prefixed' is considered to have a variable length when unparsing. Specifically, the processor automatically determines the value to store in the prefix, based on the length of the Infoset element, and the properties which modify the interpretation of the prefix length value, such as dfdl:prefixIncludesPrefixLength.

For dfdl:lengthKind 'explicit' \(expression\), whether parsing or unparsing the expression is evaluated to obtain the length. When unparsing the processor cannot automatically determine in what way the length information is to be stored as it comes from an expression that may access one or more elements and perform any calculation. Hence, normally the value of the element or elements involved in the length calculation would be computed using dfdl:outputValueCalc, using an expression that measures the length of the element by way of functions such as dfdl:contentLength or dfdl:valueLength.

When parsing, if the data stream ends without enough data to parse an element, that is, N bits are needed based on the dfdl:length, but only M &lt; N bits are available, then it is a processing error. 

If dfdl:lengthUnits is 'characters' then the length \(in bits\) of the content region \(i.e., SimpleContent or ComplexContent defined in Section 9.3 DFDL Data Syntax Grammar\) will depend on the encoding of the characters.

* If the dfdl:encoding property specifies a fixed-width encoding then the content length is the character width \(in bits\) multiplied by the length.
* If the dfdl:encoding property specifies a variable-width encoding then the length will depend on the actual characters in the element's value. The characters MUST be decoded one by one, adding up their widths \(in bits\), while counting to the specified length value.

For a simple element, dfdl:lengthUnits 'characters' may only be used for textual elements, it is a Schema Definition Error otherwise.

Some DFDL implementations MAY support character set encodings where the characters are not a multiple of 8-bits wide. Encodings which are 5, 6, 7, and 9 bits wide are rare, but do exist, so the overall length of the content region may not be a multiple of 8-bits wide.

#### 12.3.7.1 Length of Simple Elements with Textual Representation

Textual data is defined to mean either data of type string or data where the dfdl:representation property is 'text'.

For a textual element, the dfdl:lengthUnits property can be either 'bytes' or 'characters'.

**12.3.7.1.1 Text Length Specified in Bytes**

If a textual element has dfdl:lengthUnits of 'bytes', and the dfdl:encoding is not SBCS, then it is possible for a partial character encoding to appear after the code units of the characters. In this case, the following rules apply:

* When parsing, as many characters as possible are extracted from the bytes of the simple content region. Any left-over bytes are skipped. \(They are considered part of the grammar _**RightFill**_ region\).
* When unparsing, if the simple content region is larger than the encoded length of the element \(as padded when dfdl:textPadKind is not 'none'\) then the remaining bytes, which are insufficient to hold another character code, are filled with dfdl:fillByte \(Again, this is the grammar _**RightFill**_ region.\)

It is a Schema Definition Error if type is xs:string and dfdl:textPadKind is not 'none' and dfdl:lengthUnits is 'bytes' and dfdl:encoding is not an SBCS encoding and the XSD minLength facet is not zero. This prevents a scenario where validation against the XSD minLength facet is in characters, but padding would be performed in bytes.

#### 12.3.7.2 Length of Simple Elements with Binary Representation

This section discusses the dfdl:lengthKind 'explicit' and 'prefixed' specified lengths for the different binary representations. When dfdl:lengthKind is 'implicit', see Section 12.3.3 dfdl:lengthKind 'implicit'.

The dfdl:lengthUnits can be 'bytes' or 'bits' unless otherwise stated. It is Schema Definition Error if dfdl:lengthUnits is 'characters'.

It is a Schema Definition Error if the specified dfdl:length for an element of dfdl:lengthKind 'explicit' is a string literal integer such that the length of the data exceeds the capacity of the simple type.

It is a processing error if the specified length for an element of dfdl:lengthKInd 'prefixed' or 'explicit' \(with dfdl:length an expression\) is an integer such that the length of the data exceeds the capacity of the simple type.

**12.3.7.2.1 Length of Base-2 Binary Number Elements**

Non-floating point numbers with binary representation and dfdl:binaryNumberRep 'binary' are represented as a bit string which contains a base-2 representation.

The value of the specified length is constrained per the table below. The lengths are expressed in bits and are inclusive.

| Type | Minimum value of length | Maximum value of length |
| :--- | :--- | :--- |
| xs:byte | 2 | 8 |
| xs:short | 2 | 16 |
| xs:int | 2 | 32 |
| xs:long | 2 | 64 |
| xs:unsignedByte | 1 | 8 |
| xs:unsignedShort | 1 | 16 |
| xs:unsignedInt | 1 | 32 |
| xs:unsignedLong | 1 | 64 |
| xs:nonNegativeInteger | 1 | Implementation-dependent \(but not less than 64\) |
| xs:integer | 2 | Implementation-dependent \(but not less than 64\) |
| xs:decimal | 8\[36\] | Implementation-dependent \(but not less than 64\) |

Table 23: Allowable Specified Lengths in Bits for Base-2 Binary Number Elements

See Section 13.7.1.1 Converting Base-2 Binary Numbers for details of the conversion to/from numeric values.

\[36\] Type decimal must be a minimum of 8 bits because lengthUnits 'bits' is not allowed for xs:decimal.

**12.3.7.2.2 Length of Floating Point Binary Number Elements**

For binary elements of types xs:float or xs:double, a specified length must be either exactly 4 bytes or exactly 8 bytes respectively.

The dfdl:lengthUnits property must be 'bytes'. It is a Schema Definition Error otherwise.

See Section 13.8 Properties Specific to Float/Double with Binary Representation.

**12.3.7.2.3 Length of Packed Decimal Number Elements**

Non-floating-point numbers with binary representation and dfdl:binaryNumberRep 'packed', 'bcd', or 'ibm4690Packed', are represented as a bit string of 4 bit nibbles. The term packed decimal is used to describe such numbers.

It is a Schema Definition Error if the specified length is not a multiple of 4 bits.

The maximum specified length of a packed decimal number is implementation-defined.

See Section 13.7 Properties Specific to Number with Binary Representation for details of the conversion of the packed decimal bit string to/from a numeric value.

**12.3.7.2.4 Length of Binary Boolean Elements**

The specified length of a binary element of type xs:boolean is as for type xs:unsignedInt described in Section 12.3.7.2.1 Length of Base-2 Binary Number Elements.

See also Section 13.10 Properties Specific to Boolean with Binary Representation for details of how the data is converted to/from a Boolean value.

**12.3.7.2.5 Length of Base-2 Binary Calendar Elements**

Calendars \(types date, time, dateTime\) with binary representation and dfdl:binaryCalendarRep ‘binarySeconds’ or ‘binaryMilliseconds’ are represented as a bit string which contains a base-2 representation. The specified length must be either exactly 4 bytes or exactly 8 bytes respectively.

The dfdl:lengthUnits property must be 'bytes'. It is a Schema Definition Error otherwise.

See Section 13.13 Properties Specific to Calendar with Binary Representation for details of how the data is converted to/from the calendar type.

**12.3.7.2.6 Length of Packed Decimal Calendar Elements**

Calendars \(types date, time, dateTime\) with binary representation and dfdl:binaryCalendarRep 'packed', 'bcd', or 'ibm4690Packed', are represented as a bit string of 4-bit nibbles. The term packed decimal is used to describe such calendars.

It is a Schema Definition Error if the specified length is not a multiple of 4 bits.

The maximum specified length of a packed decimal calendar is implementation-defined \(but not less than 9 bytes, which corresponds to calendar pattern 'yyyyMMddhhmmssSSS'\)\[37\].

See Section 13.13 Properties Specific to Calendar with Binary Representation for details of how the data is converted to/from the calendar type.

\[37\] This is the smallest pattern that contains all the digit-only symbols. SSS is the minimum precision that must be supported for fractional seconds, but in can be more, hence why 'not less than 9 bytes'.

**12.3.7.2.7 Length of Binary Opaque Elements**

The dfdl:lengthUnits property must be 'bytes'. It is a Schema Definition Error otherwise.

When unparsing a specified length element of type xs:hexBinary, and the simple content region is larger than the length of the element in the Infoset, then the remaining bytes are filled using the dfdl:fillByte property.

The dfdl:fillByte is **not** used to trim an element of type xs:hexBinary when parsing.

#### 12.3.7.3 Length of Complex Elements

A complex element of specified length is defining a 'box' in which its child elements exist. An example of this would be a fixed-length record element with a variable number of children elements. The dfdl:lengthUnits may be 'bytes' or 'characters' and it is a Schema Definition Error otherwise.

It is possible that the children may not entirely fill the full length of the complex element. An example is a complex element with a specified length of 100 characters, which contains a sequence of child elements that use up less than 100 characters of data, perhaps because an optional element is not present. In this case the remaining unused data is called the ElementUnused region in the data syntax grammar of Section 9.3. Another example is a complex element with a specified length of 100 bytes, which contains a sequence of child elements the last of which has dfdl:lengthKind 'endOfParent', dfdl:representation 'text' and a multi-byte dfdl:encoding such that the element does not use up all the bytes of data. In this case the remaining unused bytes comprise the child element's _**RightFill**_ region in the data syntax grammar of Section 9.3. In both examples, the unused area is skipped when parsing, and is filled with the dfdl:fillByte on unparsing.

Note that a poorly chosen value for dfdl:fillByte may fill the region with data that cannot be decoded in the character set encoding, resulting in a decode error when this data is subsequently parsed again. When dfdl:lengthUnits is 'characters' the value for dfdl:fillByte must be chosen to avoid this error.

